/*****************************************************
*  TEST TEST TEST
* krnl.c  part of kernel KRNL               *
 * this version adapted for Arduino                   *
*                                                    *
* (C) 2012,2013,2014                                 *
*                                                    *
* Jens Dalsgaard Nielsen <jdn@es.aau.dk>             *
* http://es.aau.dk/staff/jdn                         *
* Section of Automation & Control                    *
* Aalborg University,                                *
* Denmark                                            *
*                                                    *
* "THE BEER-WARE LICENSE" (frit efter PHK)           *
* <jdn@es.aau.dk> wrote this file. As long as you    *
* retain this notice you can do whatever you want    *
* with this stuff. If we meet some day, and you think*
* this stuff is worth it ...                         *
*  you can buy me a beer in return :-)               *
* or if you are real happy then ...                  *
* single malt will be well received :-)              *
*                                                    *
* Use it at your own risk - no warranty              *
*                                                    *
* tested with duemilanove w/328, uno R3,             *
* seeduino 1280 and mega2560                         *
*****************************************************/


/*
First 50 mea without krnl  0.6% overhead
Next  59 mea witrh krnl    4.1% overhead
only one task created. more task and sem will increase overhead
because more elm will be checked in timer isr

Please note it is quite stable

/Jens  april 2015


1000 builtin/k-eat: 1005 / 1006
1000 builtin/k-eat: 1007 / 1006
1000 builtin/k-eat: 1006 / 1007
1000 builtin/k-eat: 1006 / 1005
1000 builtin/k-eat: 1006 / 1007
1000 builtin/k-eat: 1007 / 1006
1000 builtin/k-eat: 1005 / 1006
1000 builtin/k-eat: 1007 / 1006
1000 builtin/k-eat: 1006 / 1007
1000 builtin/k-eat: 1006 / 1006
1000 builtin/k-eat: 1007 / 1006
1000 builtin/k-eat: 1007 / 1007
1000 builtin/k-eat: 1006 / 1005
1000 builtin/k-eat: 1006 / 1007
1000 builtin/k-eat: 1007 / 1006
1000 builtin/k-eat: 1005 / 1006
1000 builtin/k-eat: 1007 / 1005
1000 builtin/k-eat: 1006 / 1007
1000 builtin/k-eat: 1006 / 1005
1000 builtin/k-eat: 1006 / 1006
1000 builtin/k-eat: 1007 / 1007
1000 builtin/k-eat: 1005 / 1005
1000 builtin/k-eat: 1007 / 1006
1000 builtin/k-eat: 1007 / 1006
1000 builtin/k-eat: 1005 / 1006
1000 builtin/k-eat: 1007 / 1005
1000 builtin/k-eat: 1006 / 1007
1000 builtin/k-eat: 1006 / 1005
1000 builtin/k-eat: 1006 / 1006
1000 builtin/k-eat: 1007 / 1006
1000 builtin/k-eat: 1005 / 1006
1000 builtin/k-eat: 1007 / 1006
1000 builtin/k-eat: 1006 / 1007
1000 builtin/k-eat: 1006 / 1007
1000 builtin/k-eat: 1007 / 1005
1000 builtin/k-eat: 1006 / 1007
1000 builtin/k-eat: 1006 / 1006
1000 builtin/k-eat: 1005 / 1006
1000 builtin/k-eat: 1007 / 1006
1000 builtin/k-eat: 1006 / 1007
1000 builtin/k-eat: 1006 / 1005
1000 builtin/k-eat: 1006 / 1007
1000 builtin/k-eat: 1007 / 1007
1000 builtin/k-eat: 1005 / 1006
1000 builtin/k-eat: 1007 / 1007
1000 builtin/k-eat: 1007 / 1006
1000 builtin/k-eat: 1005 / 1006
1000 builtin/k-eat: 1007 / 1006
1000 builtin/k-eat: 1006 / 1007
1000 builtin/k-eat: 1006 / 1005
<<
1000 builtin/k-eat: 1042 / 1042
1000 builtin/k-eat: 1041 / 1042
1000 builtin/k-eat: 1042 / 1041
1000 builtin/k-eat: 1041 / 1041
1000 builtin/k-eat: 1041 / 1042
1000 builtin/k-eat: 1041 / 1040
1000 builtin/k-eat: 1041 / 1040
1000 builtin/k-eat: 1040 / 1040
1000 builtin/k-eat: 1040 / 1041
1000 builtin/k-eat: 1042 / 1041
1000 builtin/k-eat: 1042 / 1041
1000 builtin/k-eat: 1041 / 1042
1000 builtin/k-eat: 1041 / 1042
1000 builtin/k-eat: 1042 / 1041
1000 builtin/k-eat: 1042 / 1041
1000 builtin/k-eat: 1041 / 1042
1000 builtin/k-eat: 1041 / 1042
1000 builtin/k-eat: 1042 / 1041
1000 builtin/k-eat: 1041 / 1040
1000 builtin/k-eat: 1040 / 1041
1000 builtin/k-eat: 1040 / 1041
1000 builtin/k-eat: 1041 / 1040
1000 builtin/k-eat: 1041 / 1041
1000 builtin/k-eat: 1041 / 1042
1000 builtin/k-eat: 1042 / 1041
1000 builtin/k-eat: 1042 / 1041
1000 builtin/k-eat: 1041 / 1041
1000 builtin/k-eat: 1041 / 1042
1000 builtin/k-eat: 1042 / 1041
1000 builtin/k-eat: 1042 / 1041
1000 builtin/k-eat: 1041 / 1042
1000 builtin/k-eat: 1041 / 1041
1000 builtin/k-eat: 1042 / 1040
1000 builtin/k-eat: 1040 / 1040
1000 builtin/k-eat: 1040 / 1041
1000 builtin/k-eat: 1040 / 1041
1000 builtin/k-eat: 1042 / 1041
1000 builtin/k-eat: 1041 / 1041
1000 builtin/k-eat: 1041 / 1042
1000 builtin/k-eat: 1042 / 1041
1000 builtin/k-eat: 1042 / 1041
1000 builtin/k-eat: 1041 / 1041
1000 builtin/k-eat: 1041 / 1042
1000 builtin/k-eat: 1042 / 1041
1000 builtin/k-eat: 1042 / 1041
1000 builtin/k-eat: 1041 / 1041
1000 builtin/k-eat: 1040 / 1041
1000 builtin/k-eat: 1041 / 1040
1000 builtin/k-eat: 1040 / 1040
1000 builtin/k-eat: 1041 / 1042


*/

#include <i2a.h>

#include <krnl.h>

char a[10];

void test (int msec)
{
  unsigned long t1, t2;
  i2a(a, msec);

  Serial.print(a);
    Serial.print(" builtin/k-eat: ");
  t1 = millis();
  while (msec > 10) {
    delayMicroseconds(10000);
    msec -= 10;
  }
  delayMicroseconds(msec * 1000);
  t2 = millis();
  t2 -= t1;
  ul2a(a, t2);
  Serial.print(a);

}

void ktest(int msec)
{
  unsigned long t1, t2;

  Serial.print(" / ");
  t1 = millis();
  k_eat_time(msec);
  t2 = millis();
  t2 -= t1;
  ul2a(a, t2);
  Serial.println(a);
  k_eat_time(100); // wait på rs232
}

char s1[100];
void t1()
{
  int i = 50;
  while (i--) {
    test(1000);
    ktest(1000);
  }
  while (1);
}


void setup() {
  // put your setup code here, to run once:
  Serial.begin(9600);
  for (int i = 0; i < 50; i++) {
    test(1000);
    ktest(1000);
  }
  Serial.println("<<");
  k_init(1, 0, 0);
  k_crt_task(t1, 10, s1, 100);
  k_start(1);
}

void loop() {}  // put your main code here, to run repeatedly:


The examples for krnl er enumerated k01, k02 etc
The idea is there is a progressing in the demoprograms

See github.com/jdn-aau or
es.aau.dk/staff/jdn/edu/doc/arduino/krnl

Happy krnl hacking :-)


... this file need a cleanup ... /Jens ...

/***********************

NB NB ABOUT WRAP AROUND AND KRNL TIMERS

Krnl maintain a milisecond timer (k_millis_counter)
It s 32 bit unsigned long so it wraps around after 49.7 days.
As all timing internal in krnl is relative (from now) then
wrap around will have no influence on krnl !!!

NB NB ABOUT TIMERS PORTS ETC

You can configure krnl to use timer 0,1,2,3,4,5

Default uno,mega timer 2
leonardo (32u4 cpu) timer 3

Normally you cant use timer 0 bq it is used for millis and preallocated.

YOU CAN configure KeRNeL for using timer 0.
It requires modification in ..../wiring.c where you shall disable the original INT0 timer isr in wiring.c
By setting KRNLTMR to 0 you will enable a KeRNel builtin replacement for timer0 so everything 
including millis and micros will work as usual.


See below

When using a timer you must be aware of that it will prohibit you from things like
- tone (pwm sound) uses timer2

... from http://blog.oscarliang.net/arduino-timer-and-interrupt-tutorial/

Timer0:
- Timer0 is a 8bit timer.
- In the Arduino world Timer0 is been used for the timer functions, like delay(), millis() and micros().
-  If you change Timer0 registers, this may influence the Arduino timer function.
- So you should know what you are doing.

- Timer1 is a 16bit timer.
- In the Arduino world the Servo library uses Timer1 on Arduino Uno (Timer5 on Arduino Mega).

Timer2:
 - Timer2 is a 8bit timer like Timer0.
 -In the Arduino work the tone() function uses Timer2.

Timer3 16 bits
- 1280/1284P and 2560 only

Timer4, Timer5 16 bits
- 1280 and 2560 only

On Uno
- Pins 5 and 6: controlled by timer0
- Pins 9 and 10: controlled by timer1
- Pins 11 and 3: controlled by timer2

On the Arduino Mega we have 6 timers and 15 PWM outputs:

TODO pinout below need checkup

- Pins 4 and 13: controlled by timer0
- Pins 11 and 12: controlled by timer1
- Pins 9 and10: controlled by timer2
- Pin 2, 3 and 5: controlled by timer 3
- Pin 6, 7 and 8: controlled by timer 4
- Pin 46, 45 and 44:: controlled by timer 5

... from http://arduino-info.wikispaces.com/Timers-Arduino

- Servo Library uses Timer1.
-- You can’t use PWM on Pin 9, 10 when you use the Servo Library on an Arduino.
-- For Arduino Mega it is a bit more difficult. The timer needed depends on the number of servos.
-- Each timer can handle 12 servos.
-- For the first 12 servos timer 5 will be used (losing PWM on Pin 44,45,46).
-- For 24 Servos timer 5 and 1 will be used (losing PWM on Pin 11,12,44,45,46)..
-- For 36 servos timer 5, 1 and 3 will be used (losing PWM on Pin 2,3,5,11,12,44,45,46)..
-- For 48 servos all 16bit timers 5,1,3 and 4 will be used (losing all PWM pins).

- Pin 11 has shared functionality PWM and MOSI.
-- MOSI is needed for the SPI interface, You can’t use PWM on Pin 11 and the SPI interface at the same time on Arduino.
-- On the Arduino Mega the SPI pins are on different pins.

- tone() function uses at least timer2.
-- You can’t use PWM on Pin 3,11 when you use the tone() function an Arduino and Pin 9,10 on Arduino Mega.

SO BEWARE !!!

***********************/


Jens, AAU
/* k01
    One task printing own usage of stak
*/

#include <krnl.h>

#define STKSIZE 100

#define TASKPRIO 10

char stak[STKSIZE];
struct k_t * pStak;

void task()
{
  int unusedStak;
  while (1) {
    k_eat_time(10);  // consume 10 millisec of CPU time
    k_sleep(30); // sleep 100 ticks - replacement for delay bq k_seelp releases CPU
  }
}

void setup() {
  // for debugging
  for (int i = 8; i < 14; i++)
    pinMode(i, OUTPUT);

  Serial.begin(9600);
  
  k_init(1, 0, 0); // 1 task, 0 semaphores, 0 messaegQueues */
  pStak = k_crt_task(task, TASKPRIO, stak, STKSIZE);
  k_start(1); /* start krnl timer speed 1 milliseconds*/

  Serial.println("If you see this then krnl didnt start :-( ");
}

void loop() {}

/***** DEBUGGING PART - LED ON 8-12**********/
/************************ DEBUG CALLBACK BREAKOUT PART ****************/
// must be extern C ! its not mandatory to supply with these  functions - only if you need

extern "C" {

  // called when a semphore is clipping - nr is id of semaphore and i os nr of times clip has occured
  unsigned char led13;
  void k_sem_clip(unsigned char nr, int i)
  {
    return;
    if (nr == 2)
      led13 |= 0x20;
  }

  void k_sem_noclip(unsigned char nr)
  {
    return;
    if (nr == 2)
      led13 = 0x00;
  }


  /* void k_send_Q_clip(unsigned char nr, int i) {} */

  // task numbering is in creation order: dummy: 0,  first of yours 1, next 2,...
  void k_breakout() // called every task shift from dispatcher
  {
    unsigned char c;
    PORTB  = (1 << pRun->nr); // arduino uno !! specific usage of PORTB
  }
  // for a MEGA you have to find another port :-)
  // port K (adc8-15) seems feasible
  // get inspired at http://kom.aau.dk/~jdn/edu/doc/arduino/ards.html
}




#include <krnl.h>

// A small krnl program with two independent tasks
// They run at same priority so krnl will do timeslicing between them
// Watch LED and Serial TX 

// NB only one task must use print if you dont protect the serial port by a critical section

struct k_t *pt1, // pointer to hold reference
  *pt2;          // to taskdescriptor for t1 and t2  
 
char s1[200]; // stak for task t1
char s2[200]; // stak for task t2
 
void t1(void)
{
  // a task must have an endless loop
  // if you end and leave the task function - a crash will occur!!
  // so this loop is the code body for task 1

  while (1) {  
    Serial.println("Hello World");
    k_sleep(1000); // let task sleep for 1000 kernel ticks
  }               // lenght of ticks in millisec is specified in
}                 // k_start call called from setup

void t2(void)
{
  // and task body for task 2
  // runs independent of task t1
   while (1) {
     digitalWrite(13,HIGH);  // led 13 ON
     k_sleep(500);           // sleep 500 ticks
     digitalWrite(13,LOW);   // led 13 OFF
     k_sleep(500);           // and sleep
   }
}

void setup()
{
  Serial.begin(9600);  // for output from task 1
  pinMode(13,OUTPUT);  // for blink on LED from task 2

  // init krnl so you can create 2 tasks, no semaphores and no message queues
  k_init(2,0,0); 

// two task are created
//               |------------ function used for body code for task
//               |  |--------- priority (lower number= higher prio
//               |  | |------- array used for stak for task 
//               |  | |   |--- staksize for array s1

  pt1=k_crt_task(t1,11,s1,200); 
  pt2=k_crt_task(t2,11,s2,200);
  
  
  // NB-1 remember an Arduino has only 2-8 kByte RAM
  // NB-2 remember that stak is used in function calls for
  //  - return address
  //  - registers stakked
  //  - local variabels in a function
  //  So having 200 Bytes of stak excludes a local variable like ...
  //    int arr[400];  
  // krnl call k_unused_stak returns size of unused stak
  // Both task has same priority so krnl will shift between the
  // tasks every 10 milli second (speed set in k_start)

  k_start(1); // start kernel with tick speed 1 milli seconds
}

void loop(){ /* loop will never be called */ }



  
/* k02
    One task printing own usage of stak
*/

#include <krnl.h>

#define STKSIZE 100

#define TASKPRIO 10

char stak[STKSIZE],stak2[STKSIZE];
struct k_t * pTask,*pTask2;

void task()
{
  int unusedStak;
  while (1) {
   // k_eat_time(10);  // consume 10 millisec of CPU time
  //  k_sleep(30); // sleep 100 ticks - replacement for delay bq k_seelp releases CPU
  }
}


void task2()
{
  int unusedStak;
  while (1) {
  //  k_eat_time(3);  // consume 10 millisec of CPU time
  //  k_sleep(20); // sleep 100 ticks - replacement for delay bq k_seelp releases CPU
  }
}


void setup() {
  // for debugging
  for (int i = 8; i < 14; i++)
    pinMode(i, OUTPUT);

  Serial.begin(9600);
  
  k_init(2, 0, 0); // 1 task, 0 semaphores, 0 messaegQueues */
  pTask = k_crt_task(task, TASKPRIO, stak, STKSIZE);
  pTask2 = k_crt_task(task2, TASKPRIO+1, stak2, STKSIZE);
  k_start(1); /* start krnl timer speed 1 milliseconds*/

  Serial.println("If you see this then krnl didnt start :-( ");
}

void loop() {}

/***** DEBUGGING PART - LED ON 8-12**********/
/************************ DEBUG CALLBACK BREAKOUT PART ****************/
// must be extern C ! its not mandatory to supply with these  functions - only if you need

extern "C" {

  // called when a semphore is clipping - nr is id of semaphore and i os nr of times clip has occured
  unsigned char led13;
  void k_sem_clip(unsigned char nr, int i)
  {
    return;
    if (nr == 2)
      led13 |= 0x20;
  }

  void k_sem_noclip(unsigned char nr)
  {
    return;
    if (nr == 2)
      led13 = 0x00;
  }


  /* void k_send_Q_clip(unsigned char nr, int i) {} */

  // task numbering is in creation order: dummy: 0,  first of yours 1, next 2,...
  void k_breakout() // called every task shift from dispatcher
  {
    unsigned char c;
    PORTB  = (1 << pRun->nr); // arduino uno !! specific usage of PORTB
  }
  // for a MEGA you have to find another port :-)
  // port K (adc8-15) seems feasible
  // get inspired at http://kom.aau.dk/~jdn/edu/doc/arduino/ards.html
}




#include <krnl.h>

// A small krnl program with two independent tasks
// High priority task (t1) acts like a realtime controller with
// fixed samplings frequency.
// A low priority task(t2) do non real time actions (just some printing)

struct k_t *pt1, // pointer to hold reference
*pt2,          // to taskdescriptor for t1 and t2  
*samplingsSem;

char s1[200]; // stak for task t1
char s2[200]; // stak for task t2

void toggleLED13()
{
  static char flag=0;
  if (flag) {
    flag = 0;
    digitalWrite(13,HIGH);
  }
  else {
    flag = 1;
    digitalWrite(13,LOW);
  }
}

void t1(void)
{

  k_set_sem_timer(samplingsSem,100); // krnl will signal sem every 10 tick

  while (1) {  
    // wait until next kick from timer
    // In this way we will run realtime with a fixed frequencey
    // but beware of tasks with highe priority bq they can spoil your
    // realtime bq you will be ready but not running until they leave the
    // active queue
    
    k_wait(samplingsSem,0); 
    toggleLED13(); // chk frequency with an oscilloscope 

    // AD(); 
    // pid();
    // DA();
    // hope you get the plot :-)
    
  }         
}             

void t2(void)
{
  // and task body for task 2
  // runs independent of task t1
  while (1) {
    Serial.println("tik"); // just do something non realtime :-)
    k_sleep(1000);
   }
}

void setup()
{
  Serial.begin(9600);  // for output from task 1
  pinMode(13,OUTPUT);  // for blink on LED from task 2

  // init krnl so you can create 2 tasks, 1 semaphore and no message queues
  k_init(2,1,0); 

  // two task are created
  //                |------------ function used for body code for task
  //                |  |--------- priority (lower number= higher prio
  //                |  | |------- array used for stak for task 
  //                |  | |   |--- staksize for array s1
  pt1=k_crt_task(t1,10,s1,200);  // highest prio
  pt2=k_crt_task(t2,11,s2,200);  // lowest - 10 < 11 as well as 5 < 100 :-)

  //                         |--- startvalue (can be 0,1,2, not negative 
  //                          |-- max value before maxing out
  samplingsSem = k_crt_sem(0,10);

  // NB-1 remember an Arduino has only 2-8 kByte RAM
  // NB-2 remember that stak is used in function calls for
  //  - return address
  //  - registers stakked
  //  - local variabels in a function
  //  So having 200 Bytes of stak excludes a local variable like ...
  //    int arr[400];  
  // krnl call k_unused_stak returns size of unused stak
  // Both task has same priority so krnl will shift between the
  // tasks every 10 milli second (speed set in k_start)

  k_start(1); // start kernel with tick speed 10 milli seconds
}

void loop(){ /* loop will never be called */
}





/* k03
    two tasks multitasing same priority
*/

#include <krnl.h>

#define STKSIZE 100

#define TASKPRIO 10

char stak[STKSIZE], stak2[STKSIZE];
struct k_t * pTask, *pTask2;

void task()
{
  int unusedStak;
  while (1) {
    k_eat_time(10);  // consume 10 millisec of CPU time
    k_sleep(30); // sleep 100 ticks - replacement for delay bq k_seelp releases CPU
  }
}


void task2()
{
  int unusedStak;
  while (1) {
    k_eat_time(3);  // consume 10 millisec of CPU time
    k_sleep(20); // sleep 100 ticks - replacement for delay bq k_seelp releases CPU
  }
}


void setup() {
  // for debugging
  for (int i = 8; i < 14; i++)
    pinMode(i, OUTPUT);

  Serial.begin(9600);

  k_init(2, 0, 0); // 1 task, 0 semaphores, 0 messaegQueues */
  pTask = k_crt_task(task, TASKPRIO, stak, STKSIZE);
  pTask2 = k_crt_task(task2, TASKPRIO, stak2, STKSIZE);
  k_start(1); /* start krnl timer speed 1 milliseconds*/

  Serial.println("If you see this then krnl didnt start :-( ");
}

void loop() {}

/***** DEBUGGING PART - LED ON 8-12**********/
/************************ DEBUG CALLBACK BREAKOUT PART ****************/
// must be extern C ! its not mandatory to supply with these  functions - only if you need

extern "C" {

  // called when a semphore is clipping - nr is id of semaphore and i os nr of times clip has occured
  unsigned char led13;
  void k_sem_clip(unsigned char nr, int i)
  {
    return;
    if (nr == 2)
      led13 |= 0x20;
  }

  void k_sem_noclip(unsigned char nr)
  {
    return;
    if (nr == 2)
      led13 = 0x00;
  }


  /* void k_send_Q_clip(unsigned char nr, int i) {} */

  // task numbering is in creation order: dummy: 0,  first of yours 1, next 2,...
  void k_breakout() // called every task shift from dispatcher
  {
    unsigned char c;
    PORTB  = (1 << pRun->nr); // arduino uno !! specific usage of PORTB
  }
  // for a MEGA you have to find another port :-)
  // port K (adc8-15) seems feasible
  // get inspired at http://kom.aau.dk/~jdn/edu/doc/arduino/ards.html
}




#include <krnl.h>

// A small krnl program with two independent tasks
// They share data which is guarded by a semaphore implemented mutex 
// Tasks has same priority in this examples
// you can have more mutex regions by using more sempahores :-)

struct k_t *pt1, // pointer to hold reference
*pt2,          // to taskdescriptor for t1 and t2  
*mutexSem; 

char s1[200]; // stak for task t1
char s2[200]; // stak for task t2

void toggleLED13()
{
  static char flag=0;
  if (flag) {
    flag = 0;
    digitalWrite(13,HIGH);
  }
  else {
    flag = 1;
    digitalWrite(13,LOW);
  }
}

void t1(void)
{
  while (1) {
    // just wait until you get region
    
    k_wait(mutexSem,0); 
    // CRITICAL REGION STARTS
    // when I am in between the wait and signal task t2 cant be in its similar region
    // bq I have the token (semaphore initialised to 1)
    // and ofcourse the same for t2 versus t1
    digitalWrite(13,HIGH);
    k_sleep(700);
    digitalWrite(13,LOW);

    // CRITICAL REGION ENDS
    k_signal(mutexSem);
  }
}             

void t2(void)
{
  // and task body for task 2
  // runs independent of task t1
  while (1) {
    k_wait(mutexSem,0); // just wait until you get region
    // CRITICAL REGION STARTS
    Serial.println("t1 got it");
    k_sleep(100);
    
    // CRITICAL REGION ENDS
    k_signal(mutexSem);    
  }
}

void setup()
{
  Serial.begin(9600);  // for output from task 1
  pinMode(13,OUTPUT);  // for blink on LED from task 2

  // init krnl so you can create 2 tasks, 1 semaphore and no message queues
  k_init(2,1,0); 

  // two task are created
  //                |------------ function used for body code for task
  //                |  |--------- priority (lower number= higher prio
  //                |  | |------- array used for stak for task 
  //                |  | |   |--- staksize for array s1
  pt1=k_crt_task(t1,11,s1,200);  // 
  pt2=k_crt_task(t2,11,s2,200);  //  

  //                    |--- startvalue is 1 bq it is for mutex usage
  //                       |-- max value before maxing out
  mutexSem = k_crt_sem(1,10);

  k_start(1); // start kernel with tick speed 10 milli seconds
}

void loop(){ /* loop will never be called */
}






/* k04
 *  as k03 but now task has higher priority so it can take cpu from task2 when needed :-)
*/

#include <krnl.h>

#define STKSIZE 100

#define TASKPRIO 10

char stak[STKSIZE], stak2[STKSIZE];
struct k_t * pTask, *pTask2;

void task()
{
  int unusedStak;
  while (1) {
    k_eat_time(10);  // consume 10 millisec of CPU time
    k_sleep(30); // sleep 100 ticks - replacement for delay bq k_seelp releases CPU
  }
}


void task2()
{
  int unusedStak;
  while (1) {
    k_eat_time(3);  // consume 10 millisec of CPU time
    k_sleep(20); // sleep 100 ticks - replacement for delay bq k_seelp releases CPU
  }
}


void setup() {
  // for debugging
  for (int i = 8; i < 14; i++)
    pinMode(i, OUTPUT);

  Serial.begin(9600);

  k_init(2, 0, 0); // 1 task, 0 semaphores, 0 messaegQueues */
  pTask = k_crt_task(task, TASKPRIO, stak, STKSIZE);
  pTask2 = k_crt_task(task2, TASKPRIO+1, stak2, STKSIZE); // +1 == lower priority
  k_start(1); /* start krnl timer speed 1 milliseconds*/

  Serial.println("If you see this then krnl didnt start :-( ");
}

void loop() {}

/***** DEBUGGING PART - LED ON 8-12**********/
/************************ DEBUG CALLBACK BREAKOUT PART ****************/
// must be extern C ! its not mandatory to supply with these  functions - only if you need

extern "C" {

  // called when a semphore is clipping - nr is id of semaphore and i os nr of times clip has occured
  unsigned char led13;
  void k_sem_clip(unsigned char nr, int i)
  {
    return;
    if (nr == 2)
      led13 |= 0x20;
  }

  void k_sem_noclip(unsigned char nr)
  {
    return;
    if (nr == 2)
      led13 = 0x00;
  }


  /* void k_send_Q_clip(unsigned char nr, int i) {} */

  // task numbering is in creation order: dummy: 0,  first of yours 1, next 2,...
  void k_breakout() // called every task shift from dispatcher
  {
    unsigned char c;
    PORTB  = (1 << pRun->nr); // arduino uno !! specific usage of PORTB
  }
  // for a MEGA you have to find another port :-)
  // port K (adc8-15) seems feasible
  // get inspired at http://kom.aau.dk/~jdn/edu/doc/arduino/ards.html
}




#include <krnl.h>

// A small krnl program with two independent tasks
// They share data which is guarded by a semaphore implemented mutex 
// Tasks has same priority in this examples
// you can have more mutex regions by using more sempahores :-)

struct k_t *pt1, // pointer to hold reference
*pt2,          // to taskdescriptor for t1 and t2  
*mutexSem; 

char s1[200]; // stak for task t1
char s2[200]; // stak for task t2

void toggleLED13()
{
  static char flag=0;
  if (flag) {
    flag = 0;
    digitalWrite(13,HIGH);
  }
  else {
    flag = 1;
    digitalWrite(13,LOW);
  }
} 
}

void setup()
{
  Serial.begin(9600);  // for output from task 1
  pinMode(13,OUTPUT);  // for blink on LED from task 2

  // init krnl so you can create 2 tasks, 1 semaphore and no message queues
  k_init(2,1,0); 

  // two task are created
  //                |------------ function used for body code for task
  //                |  |--------- priority (lower number= higher prio
  //                |  | |------- array used for stak for task 
  //                |  | |   |--- staksize for array s1
  pt1=k_crt_task(t1,11,s1,200);  // 
  pt2=k_crt_task(t2,11,s2,200);  //  

  //                    |--- startvalue is 1 bq it is for mutex usage
  //                       |-- max value before maxing out
  mutexSem = k_crt_sem(1,10);

  k_start(1); // start kernel with tick speed 10 milli seconds
}

void loop(){ /* loop will never be called */
}






/* k05
    Critical region by semaphore
    task update data and task2 use them

*/

#include <krnl.h>

#define STKSIZE 100

#define TASKPRIO 10

char stak[STKSIZE], stak2[STKSIZE];
struct k_t * pTask, *pTask2, *sem1;

volatile char reg = 0;
 
void task()
{
  int res;
  while (1) {
    res = k_wait(sem1, 0); // knock knock at sem1. timeout = 0 means forever
    
    DI();  // just for setting bit for critical region for osc
    reg =  0x08;
    PORTB = (1 << pRun->nr) | reg;
    EI();

    k_eat_time(10);  // consume 10 millisec of CPU time

    DI();
    reg = 0; // reset crit reg pin
    PORTB = (1 << pRun->nr) | reg;
    EI();

    k_signal(sem1);

    k_sleep(1);
    k_eat_time(3);
    k_sleep(30); // sleep 100 ticks - replacement for delay bq k_seelp releases CPU
  }
}

void task2()
{
  int res;
  while (1) {
    res = k_wait(sem1, 0); // knock knock at sem1. timeout = 0 menans forever
    DI();  // just for setting bit for critical region for osc
    reg =  0x10;
    PORTB = (1 << pRun->nr) | reg;
    EI();

    k_eat_time(3);  // consume 10 millisec of CPU time

    DI();
    reg = 0;
    PORTB = (1 << pRun->nr) | reg;
    EI();

    k_signal(sem1);
    k_sleep(1);
    k_eat_time(1);

    k_sleep(20); // sleep 100 ticks - replacement for delay bq k_seelp releases CPU
  }
}


void setup() {
  // for debugging
  for (int i = 8; i < 14; i++)
    pinMode(i, OUTPUT);

  Serial.begin(9600);

  k_init(2, 2, 0); // 2 task, 1 semaphores, 0 messaegQueues */
  pTask = k_crt_task(task, TASKPRIO, stak, STKSIZE);
  pTask2 = k_crt_task(task2, TASKPRIO, stak2, STKSIZE); // +1 == lower priority

  sem1 = k_crt_sem(1, 10); // 1: start value, 10: max value (clipping)
  k_start(1); /* start krnl timer speed 1 milliseconds*/

  Serial.println("If you see this then krnl didnt start :-( ");
}

void loop() {}

/***** DEBUGGING PART - LED ON 8-12**********/
/************************ DEBUG CALLBACK BREAKOUT PART ****************/
// must be extern C ! its not mandatory to supply with these  functions - only if you need

extern "C" {

  // called when a semphore is clipping - nr is id of semaphore and i os nr of times clip has occured
  unsigned char led13;
  ;
  void k_sem_clip(unsigned char nr, int i)
  {
    return;
    if (nr == 2)
      led13 |= 0x20;
  }

  void k_sem_noclip(unsigned char nr)
  {
    return;
    if (nr == 2)
      led13 = 0x00;
  }


  /* void k_send_Q_clip(unsigned char nr, int i) {} */

  // task numbering is in creation order: dummy: 0,  first of yours 1, next 2,...
  void k_breakout() // called every task shift from dispatcher
  {
    unsigned char c;
    PORTB  = (1 << pRun->nr) | reg; // arduino uno !! specific usage of PORTB
  }
  // for a MEGA you have to find another port :-)
  // port K (adc8-15) seems feasible
  // get inspired at http://kom.aau.dk/~jdn/edu/doc/arduino/ards.html
}





/* k06
    Critical region by semaphore
    task update data and task2 use them
    task has higher priority than task 2

*/

#include <krnl.h>

#define STKSIZE 100

#define TASKPRIO 10

char stak[STKSIZE], stak2[STKSIZE];
struct k_t * pTask, *pTask2, *sem1;

volatile char reg = 0;
 
void task()
{
  int res;
  while (1) {
    res = k_wait(sem1, 0); // knock knock at sem1. timeout = 0 means forever
    
    DI();  // just for setting bit for critical region for osc
    reg =  0x08;
    PORTB = (1 << pRun->nr) | reg;
    EI();

    k_eat_time(10);  // consume 10 millisec of CPU time

    DI();
    reg = 0; // reset crit reg pin
    PORTB = (1 << pRun->nr) | reg;
    EI();

    k_signal(sem1);

    k_sleep(1);
    k_eat_time(3);
    k_sleep(30); // sleep 100 ticks - replacement for delay bq k_seelp releases CPU
  }
}

void task2()  // lower prority than task above
{
  int res;
  while (1) {
    res = k_wait(sem1, 0); // knock knock at sem1. timeout = 0 menans forever
    DI();  // just for setting bit for critical region for osc
    reg =  0x10;
    PORTB = (1 << pRun->nr) | reg;
    EI();

    k_eat_time(3);  // consume 10 millisec of CPU time

    DI();
    reg = 0;
    PORTB = (1 << pRun->nr) | reg;
    EI();

    k_signal(sem1);
    k_sleep(1);
    k_eat_time(1);

    k_sleep(20); // sleep 100 ticks - replacement for delay bq k_seelp releases CPU
  }
}


void setup() {
  // for debugging
  for (int i = 8; i < 14; i++)
    pinMode(i, OUTPUT);

  Serial.begin(9600);

  k_init(2, 2, 0); // 2 task, 1 semaphores, 0 messaegQueues */
  pTask = k_crt_task(task, TASKPRIO, stak, STKSIZE);
  pTask2 = k_crt_task(task2, TASKPRIO+1, stak2, STKSIZE); // +1 == lower priority

  sem1 = k_crt_sem(1, 10); // 1: start value, 10: max value (clipping)
  k_start(1); /* start krnl timer speed 1 milliseconds*/

  Serial.println("If you see this then krnl didnt start :-( ");
}

void loop() {}

/***** DEBUGGING PART - LED ON 8-12**********/
/************************ DEBUG CALLBACK BREAKOUT PART ****************/
// must be extern C ! its not mandatory to supply with these  functions - only if you need

extern "C" {

  // called when a semphore is clipping - nr is id of semaphore and i os nr of times clip has occured
  unsigned char led13;
  ;
  void k_sem_clip(unsigned char nr, int i)
  {
    return;
    if (nr == 2)
      led13 |= 0x20;
  }

  void k_sem_noclip(unsigned char nr)
  {
    return;
    if (nr == 2)
      led13 = 0x00;
  }


  /* void k_send_Q_clip(unsigned char nr, int i) {} */

  // task numbering is in creation order: dummy: 0,  first of yours 1, next 2,...
  void k_breakout() // called every task shift from dispatcher
  {
    unsigned char c;
    PORTB  = (1 << pRun->nr) | reg; // arduino uno !! specific usage of PORTB
  }
  // for a MEGA you have to find another port :-)
  // port K (adc8-15) seems feasible
  // get inspired at http://kom.aau.dk/~jdn/edu/doc/arduino/ards.html
}





/* k07
    Critical region by semaphore
    task update data and task2 use them
    task has higher priority than task 2

*/

#include <krnl.h>

#define STKSIZE 100

#define TASKPRIO 10

char stak[STKSIZE], stak2[STKSIZE];
struct k_t * pTask, *pTask2, *sem1;

volatile char reg = 0;
 
void task()
{
  int res;
  while (1) {
    res = k_wait(sem1, 0); // knock knock at sem1. timeout = 0 means forever
    
    DI();  // just for setting bit for critical region for osc
    reg =  0x08;
    PORTB = (1 << pRun->nr) | reg;
    EI();

    k_eat_time(10);  // consume 10 millisec of CPU time

    DI();
    reg = 0; // reset crit reg pin
    PORTB = (1 << pRun->nr) | reg;
   
    k_signal(sem1);

    k_sleep(1);
    k_eat_time(3);
    k_sleep(30); // sleep 100 ticks - replacement for delay bq k_seelp releases CPU
  }
}

void task2()    // same priority
{
  int res;
  while (1) {
    res = k_wait(sem1, 0); // knock knock at sem1. timeout = 0 menans forever
    DI();  // just for setting bit for critical region for osc
    reg =  0x10;
    PORTB = (1 << pRun->nr) | reg;
    EI();

    k_eat_time(3);  // consume 10 millisec of CPU time

    DI();
    reg = 0;
    PORTB = (1 << pRun->nr) | reg;

    k_signal(sem1);
    k_sleep(1);
    k_eat_time(1);

    k_sleep(20); // sleep 100 ticks - replacement for delay bq k_seelp releases CPU
  }
}


void setup() {
  // for debugging
  for (int i = 8; i < 14; i++)
    pinMode(i, OUTPUT);

  Serial.begin(9600);

  k_init(2, 2, 0); // 2 task, 1 semaphores, 0 messaegQueues */
  pTask = k_crt_task(task, TASKPRIO, stak, STKSIZE);
  pTask2 = k_crt_task(task2, TASKPRIO, stak2, STKSIZE); // +1 == lower priority

  sem1 = k_crt_sem(1, 10); // 1: start value, 10: max value (clipping)
  k_start(1); /* start krnl timer speed 1 milliseconds*/

  Serial.println("If you see this then krnl didnt start :-( ");
}

void loop() {}

/***** DEBUGGING PART - LED ON 8-12**********/
/************************ DEBUG CALLBACK BREAKOUT PART ****************/
// must be extern C ! its not mandatory to supply with these  functions - only if you need

extern "C" {

  // called when a semphore is clipping - nr is id of semaphore and i os nr of times clip has occured
  unsigned char led13;
  ;
  void k_sem_clip(unsigned char nr, int i)
  {
    return;
    if (nr == 2)
      led13 |= 0x20;
  }

  void k_sem_noclip(unsigned char nr)
  {
    return;
    if (nr == 2)
      led13 = 0x00;
  }


  /* void k_send_Q_clip(unsigned char nr, int i) {} */

  // task numbering is in creation order: dummy: 0,  first of yours 1, next 2,...
  void k_breakout() // called every task shift from dispatcher
  {
    unsigned char c;
    PORTB  = (1 << pRun->nr) | reg; // arduino uno !! specific usage of PORTB
  }
  // for a MEGA you have to find another port :-)
  // port K (adc8-15) seems feasible
  // get inspired at http://kom.aau.dk/~jdn/edu/doc/arduino/ards.html
}





/* k08
    Critical region by semaphore
    task update data and task2 use them
    task has higher priority than task 2

*/

#include <krnl.h>

#define STKSIZE 100

#define TASKPRIO 10

char stak[STKSIZE], stak2[STKSIZE];
struct k_t * pTask, *pTask2, *sem1;

volatile char reg = 0;
 
void task()
{
  int res;
  while (1) {
    res = k_wait(sem1, 0); // knock knock at sem1. timeout = 0 means forever
    
    DI();  // just for setting bit for critical region for osc
    reg =  0x08;
    PORTB = (1 << pRun->nr) | reg;
    EI();

    k_eat_time(10);  // consume 10 millisec of CPU time

    DI();
    reg = 0; // reset crit reg pin
    PORTB = (1 << pRun->nr) | reg;
   
    k_signal(sem1);

    k_sleep(1);
    k_eat_time(3);
    k_sleep(30); // sleep 100 ticks - replacement for delay bq k_seelp releases CPU
  }
}

void task2()  // lower prority than task above
{
  int res;
  while (1) {
    res = k_wait(sem1, 0); // knock knock at sem1. timeout = 0 menans forever
    DI();  // just for setting bit for critical region for osc
    reg =  0x10;
    PORTB = (1 << pRun->nr) | reg;
    EI();

    k_eat_time(3);  // consume 10 millisec of CPU time

    DI();
    reg = 0;
    PORTB = (1 << pRun->nr) | reg;

    k_signal(sem1);
    k_sleep(1);
    k_eat_time(1);

    k_sleep(20); // sleep 100 ticks - replacement for delay bq k_seelp releases CPU
  }
}


void setup() {
  // for debugging
  for (int i = 8; i < 14; i++)
    pinMode(i, OUTPUT);

  Serial.begin(9600);

  k_init(2, 2, 0); // 2 task, 1 semaphores, 0 messaegQueues */
  pTask = k_crt_task(task, TASKPRIO, stak, STKSIZE);
  pTask2 = k_crt_task(task2, TASKPRIO+1, stak2, STKSIZE); // +1 == lower priority

  sem1 = k_crt_sem(1, 10); // 1: start value, 10: max value (clipping)
  k_start(1); /* start krnl timer speed 1 milliseconds*/

  Serial.println("If you see this then krnl didnt start :-( ");
}

void loop() {}

/***** DEBUGGING PART - LED ON 8-12**********/
/************************ DEBUG CALLBACK BREAKOUT PART ****************/
// must be extern C ! its not mandatory to supply with these  functions - only if you need

extern "C" {

  // called when a semphore is clipping - nr is id of semaphore and i os nr of times clip has occured
  unsigned char led13;
  ;
  void k_sem_clip(unsigned char nr, int i)
  {
    return;
    if (nr == 2)
      led13 |= 0x20;
  }

  void k_sem_noclip(unsigned char nr)
  {
    return;
    if (nr == 2)
      led13 = 0x00;
  }


  /* void k_send_Q_clip(unsigned char nr, int i) {} */

  // task numbering is in creation order: dummy: 0,  first of yours 1, next 2,...
  void k_breakout() // called every task shift from dispatcher
  {
    unsigned char c;
    PORTB  = (1 << pRun->nr) | reg; // arduino uno !! specific usage of PORTB
  }
  // for a MEGA you have to find another port :-)
  // port K (adc8-15) seems feasible
  // get inspired at http://kom.aau.dk/~jdn/edu/doc/arduino/ards.html
}





/* k09
     
     sampling with fixed frequency with timer on sempahore

*/

#include <krnl.h>

#define STKSIZE 100

#define TASKPRIO 10

char stak[STKSIZE], stak2[STKSIZE];
struct k_t * pTask, *pTask2, *sem1;

volatile char reg = 0;

void task()
{
  int res;

  k_set_sem_timer(sem1, 10); // krnl signals every 10 msec
  
  while (1) {
    res = k_wait(sem1, 0); // knock knock at sem1. timeout = 0 means forever
    k_eat_time(3);
  }
}


void setup() {
  // for debugging
  for (int i = 8; i < 14; i++)
    pinMode(i, OUTPUT);

  Serial.begin(9600);

  k_init(1, 1, 0); // 2 task, 1 semaphores, 0 messaegQueues */
  pTask = k_crt_task(task, TASKPRIO, stak, STKSIZE);

  sem1 = k_crt_sem(0, 10); // 1: start value, 10: max value (clipping)
  k_start(1); /* start krnl timer speed 1 milliseconds*/

  Serial.println("If you see this then krnl didnt start :-( ");
}

void loop() {}

/***** DEBUGGING PART - LED ON 8-12**********/
/************************ DEBUG CALLBACK BREAKOUT PART ****************/
// must be extern C ! its not mandatory to supply with these  functions - only if you need

extern "C" {

  // called when a semphore is clipping - nr is id of semaphore and i os nr of times clip has occured
  unsigned char led13;
  ;
  void k_sem_clip(unsigned char nr, int i)
  {
    return;
    if (nr == 2)
      led13 |= 0x20;
  }

  void k_sem_noclip(unsigned char nr)
  {
    return;
    if (nr == 2)
      led13 = 0x00;
  }


  /* void k_send_Q_clip(unsigned char nr, int i) {} */

  // task numbering is in creation order: dummy: 0,  first of yours 1, next 2,...
  void k_breakout() // called every task shift from dispatcher
  {
    unsigned char c;
    PORTB  = (1 << pRun->nr) | reg; // arduino uno !! specific usage of PORTB
  }
  // for a MEGA you have to find another port :-)
  // port K (adc8-15) seems feasible
  // get inspired at http://kom.aau.dk/~jdn/edu/doc/arduino/ards.html
}




#include <krnl.h>

// A small krnl program with two independent tasks
// They run at same priority so krnl will do timeslicing between them
// Watch LED and Serial TX 

struct k_t *pt1, // pointer to hold reference
  *pt2;          // to taskdescriptor for t1 and t2  
 
char s1[200]; // stak for task t1
char s2[200]; // stak for task t2
 
void t1(void)
{
  // a task must have an endless loop
  // if you end and leave the task function - a crash will occur!!
  // so this loop is the code body for task 1
  while (1) {  
    Serial.println("Hello World");
    k_sleep(1000); // let task sleep for 1000 kernel ticks
  }               // lenght of ticks in millisec is specified in
}                 // k_start call called from setup

void t2(void)
{
  // and task body for task 2
  // runs independent of task t1
   while (1) {
     digitalWrite(13,HIGH);  // led 13 ON
     k_sleep(500);           // sleep 500 ticks
     digitalWrite(13,LOW);   // led 13 OFF
     k_sleep(500);           // and sleep
   }
}

void setup()
{
  Serial.begin(9600);  // for output from task 1
  pinMode(13,OUTPUT);  // for blink on LED from task 2

  // init krnl so you can create 2 tasks, 0 semaphores and no message queues
  k_init(2,0,0); 

// two task are created
//               |------------ function used for body code for task
//               |  |--------- priority (lower number= higher prio
//               |  | |------- array used for stak for task 
//               |  | |   |--- staksize for array s1

  pt1=k_crt_task(t1,11,s1,200); 
  pt2=k_crt_task(t2,11,s2,200);
  
  
  // NB-1 remember an Arduino has only 2-8 kByte RAM
  // NB-2 remember that stak is used in function calls for
  //  - return address
  //  - registers stakked
  //  - local variabels in a function
  //  So having 200 Bytes of stak excludes a local variable like ...
  //    int arr[400];  
  // krnl call k_unused_stak returns size of unused stak
  // Both task has same priority so krnl will shift between the
  // tasks every 10 milli second (speed set in k_start)

  k_start(1); // start kernel with tick speed 10 milli seconds
}

void loop(){ /* loop will never be called */ }



